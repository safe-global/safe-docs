import { Tabs } from "nextra/components";

# `sendOffChainMessage`

The `sendOffChainMessage` method creates off-chain messages in your Safe account. Safe Wallet's default is off-chain messages, so this method helps with Safe creation and message storage by leveraging the Transaction Service.

Two scenarios can happen.

If the Safe account is already deployed (you are using the `safeAddress` or the `safeOptions` counterfactual address prediction derives an existing Safe account). In this case:

  - The message will be stored using the Transaction Service.
  - If the Safe is a multisig (threshold > 1), more signatures (confirmations) will be required. In that case, you can use the `confirmOffChainMessage` method.

If the Safe account has not yet been deployed (you are using `safeOptions` and the counterfactual address prediction results in a non-existing Safe account):

  - In the case the Safe is a multisig account, the `sendOffChainMessage` method will add the message, just as in the previous case. However, the Safe account will also be deployed using the funds in the current `signer` account.
  - In the case the safe is a single-owner account, the message is automatically confirmed and valid.

## Usage

{/* <!-- vale off --> */}

<Tabs items={["send-off-chain-message.ts", "setup.ts"]}>
  <Tabs.Tab>
    ```typescript 
      import { offChainMessages } from '@safe-global/sdk-starter-kit'

      const message = "I am the owner of this Safe ğŸ’ªğŸ»"
      const safeMessageClient = safeClient.extend(offChainMessages())
      const messageResult = await safeMessageClient.sendOffChainMessage({ message })
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```typescript      
      import { createSafeClient } from '@safe-global/sdk-starter-kit'

      const safeClient = await createSafeClient({
        provider,  
        signer,
        safeAddress
      })      
    ```

  </Tabs.Tab>
</Tabs>

{/* <!-- vale on --> */}

## Returns

`SafeClientResult`

An object with the result of the operation.

## Parameters

### `message`

- **Type:** `string | EIP712TypedData`

The message can be a raw string or an [EIP-712](https://eips.ethereum.org/EIPS/eip-712) compatible data object.
