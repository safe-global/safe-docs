import { Tabs } from "nextra/components";

# `confirmSafeOperation`

Confirms the stored safeOperation. Remember when using `sendSafeOperation` if the number of signatures is not enough then the operations it's being stored using Safe services so you need to confirm it with other Safe owners.

When enough signatures are collected the operation will be sent to the bundler to be executed.

## Usage

{/* <!-- vale off --> */}

<Tabs items={["confirm-safe-operation.ts", "setup.ts"]}>
  <Tabs.Tab>
  ```typescript 
    const safeOperationHash = '0x...'    
    const safeOperationResult = await safeClient.confirmSafeOperation({ 
      safeOperationHash
    })
  ```
  </Tabs.Tab>
  <Tabs.Tab>
  ```typescript 
      const safeClient = await createSafeClient({
        provider,  
        signer,
        safeAddress
      })

      const safeOperationsClient = await safeClient.extend(safeOperations({
          bundlerUrl
        },
        {
          isSponsored,
          paymasterUrl
        }
      }))

````
</Tabs.Tab>
</Tabs>

{/* <!-- vale on --> */}

## Returns

`SafeClientResult`

An object with the result of the send operation.

## Parameters

### `safeTxHash`

- **Type:** `string`

The safe transaction hash. This is not the same as the ethereum hash as the transaction is not executed yet. You need to use this hash that is computed and stored in out Transaction Service.

To get the hash an application that tries to confirm transactions can use the `getPendingTransactions()` method to obtain the different pending transactions and its hashes.

```typescript
const safeTxHashToSearch = '0x...'
const pendingTransactions = await safeClient.getPendingTransactions()

for (const transaction of pendingTransactions.results) {
  if (transaction.safeTxHash !== safeTxHashToSearch) {
    return
  }

  const txResult = await safeClient.confirm({ safeTxHash: transaction.safeTxHash })
}
````
