import { Callout } from 'nextra/components'


# How to build an app with Safe and Safe Module

In this tutorial, you will build an app that can:

- Build a Safe Module
- Enable an example module on a Safe (the [TokenTransferModule](https://github.com/5afe/safe-module-tutorial-contracts) module)
- Send a transaction via the TokenTransferModule (Send a transaction that transfers ERC20 token from the Safe account)

The full code for this tutorial is in the [Safe Module tutorial repository](https://github.com/5afe/safe-module-tutorial).

## Prerequisites

**Prerequisite knowledge:** You will need some basic experience with [React](https://react.dev/learn), [Next.js](https://nextjs.org/docs), [Solidity](https://docs.soliditylang.org/en/latest/) and [Hardhat](https://hardhat.org).

Before progressing with the tutorial, please make sure you have the following:

- Downloaded and installed [Node.js](https://nodejs.org/en/download/package-manager) and [pnpm](https://pnpm.io/installation).
- Metamask installed in your browser and connected to the Sepolia network.
- Two test accounts in Metamask, the second with some Sepolia Eth for gas.

## Setup contracts repository

This tutorial will provide a guide to create a Safe Module that allows users to withdraw ERC20 tokens from a Safe account, provided that the Safe owners have given their approval in the form of off-chain signatures. The primary use case is to enable beneficiaries to withdraw tokens themselves without requiring the Safe owners to execute transactions directly.

### Use cases
- Simplifies token withdrawal by enabling beneficiaries to perform withdrawals themselves.
- Reduces the need for Safe owners to execute each transaction on-chain.

### Limitations
- Beneficiaries must be externally owned accounts (EOAs) and cannot be smart contracts.
- The nonce is sequential for simplicity
- The contract will work only for specific token and Safe address provided during deployment.

### Initialize a new repository

```bash
git init
```

```bash
pnpm init
```

### Install dependencies

```bash
pnpm add hardhat @safe-global/safe-contracts
```

### Initialize hardhat project

Select create TypeScript project.

```bash
npx hardhat init
```

```bash
npx hardhat compile
```

### Create a new Solidity contract

Delete the default `Lock.sol` and test file `Lock.ts` and create a new Solidity contract `TokenTransferModule.sol` in the `contracts` directory.

`TokenTransferModule.sol` will contain the module code which will be used further in the tutorial for interacting with the UI.

#### Step 1. Create empty contract

```solidity
// SPDX-License-Identifier: LGPL-3.0
pragma solidity ^0.8.0;

contract TokenTransferModule {
}
```

Explanation:
- **SPDX License Identifier**: Specifies the license type.
- **`pragma solidity ^0.8.0`**: Defines the Solidity compiler version.
- **`contract TokenWithdrawModule`**: Declares the contract name.

#### Step 2: Import required dependencies


```solidity
import "@safe-global/safe-contracts/contracts/common/Enum.sol";
import "@safe-global/safe-contracts/contracts/Safe.sol";
```

Explanation:
- **`Enum.sol`**: Provides Enum `Operation` which can have values like `Call` or `DelegateCall`. This will be used further in the contract when a module calls a Safe account where the module specifies the operation type.
- **`Safe.sol`**: Includes the Safe contract interface to interact with Safe accounts.

#### Step 3: Define state variables

Declare the necessary state variables for the contract.

```solidity
bytes32 public immutable PERMIT_TYPEHASH =
    keccak256(
        "TokenTransfer(uint256 amount, address _beneficiary, uint256 nonce, uint256 deadline)"
    );
address public immutable safeAddress;
address public immutable tokenAddress;
mapping(address => uint256) public nonces;
```

Explanation:
- **`PERMIT_TYPEHASH`**: Used to construct the signature hash for the token transfer. 
- **`safeAddress`**: Stores the Safe contract address.
- **`tokenAddress`**: Stores the ERC20 token contract address.
- **`nonces`**: Tracks unique nonce to prevent replay attacks.

#### Step 4: Create the Constructor

Define a constructor to initialize the Safe and token contract addresses.

```solidity
constructor(address _tokenAddress, address _safeAddress) {
    tokenAddress = _tokenAddress;
    safeAddress = _safeAddress;
}
```

- Initializes `tokenAddress` and `safeAddress` with provided values during deployment. Thus, in this module the token and Safe addresses are fixed.

#### Step 5: Implement the `tokenTransfer` function

Add a function to handle token transfers from the Safe.

```solidity
function tokenTransfer(
    uint _amount,
    address _beneficiary,
    uint256 _deadline,
    bytes memory _signatures
) public {
    require(_deadline >= block.timestamp, "expired deadline");

    bytes32 signatureData = keccak256(
        abi.encode(
            PERMIT_TYPEHASH,
            _amount,
            msg.sender,
            nonces[msg.sender]++,
            _deadline
        )
    );

    bytes32 hash = keccak256(
        abi.encodePacked("\x19\x01", getDomainSeparator(), signatureData)
    );

    Safe(payable(safeAddress)).checkSignatures(
        hash,
        abi.encodePacked(signatureData),
        _signatures
    );

    bytes memory data = abi.encodeWithSignature(
        "transfer(address,uint256)",
        _beneficiary,
        _amount
    );

    require(
        Safe(payable(safeAddress)).execTransactionFromModule(
            tokenAddress,
            0,
            data,
            Enum.Operation.Call
        ),
        "Could not execute token transfer"
    );
}
```

Explanation:
1. **Parameter Validation**:
   - Ensure the `_deadline` is valid.
   - Construct `signatureData` with the provided details and `PERMIT_TYPEHASH`.
2. **Hash Calculation**:
   - Compute the hash using the `EIP712` format to ensure signature consistency.
3. **Signature Verification**:
   - Call `checkSignatures` on the Safe to verify the signatures provided match the owners of the Safe.
4. **Transaction Execution**:
   - A module can use `execwhenTransactionFromModule` or `execTransactionFromModuleReturnData` function to execute transactions through a Safe account on which the module is enabled.
   - Encode the transfer call using `abi.encodeWithSignature`.
   - Use `execTransactionFromModule` to execute the token transfer via the Safe.
   - Ensure execution succeeds, otherwise revert.

#### Step 6: Implement the `getDomainSeparator` function

Add a helper function to compute the EIP-712 domain separator.

```solidity
function getDomainSeparator() private view returns (bytes32) {
    uint256 chainId;
    assembly {
        chainId := chainid()
    }

    return keccak256(
        abi.encode(
            keccak256(
                "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
            ),
            keccak256(bytes("TokenWithdrawModule")),
            keccak256(bytes("1")),
            chainId,
            address(this)
        )
    );
}
```

Explanation:
- Computes the `EIP712Domain` separator for the current chain and contract.
- Ensures compatibility with the EIP-712 standard for off-chain signing.
- Using a Domain separator ensures that the signature is valid for specific contracts in context and the chain. Thus, preventing replay attacks.

#### Final contract code

Here is the complete code for reference:

```solidity
// SPDX-License-Identifier: LGPL-3.0
pragma solidity ^0.8.0;
import "@safe-global/safe-contracts/contracts/common/Enum.sol";
import "@safe-global/safe-contracts/contracts/Safe.sol";

contract TokenWithdrawModule {
    bytes32 public immutable PERMIT_TYPEHASH =
        keccak256(
            "TokenTransfer(uint256 amount, address _beneficiary, uint256 nonce, uint256 deadline)"
        );
    address public immutable safeAddress;
    address public immutable tokenAddress;
    mapping(address => uint256) public nonces;

    constructor(address _tokenAddress, address _safeAddress) {
        tokenAddress = _tokenAddress;
        safeAddress = _safeAddress;
    }

    function tokenTransfer(
        uint _amount,
        address _beneficiary,
        uint256 _deadline,
        bytes memory _signatures
    ) public {
        require(_deadline >= block.timestamp, "expired deadline");

        bytes32 signatureData = keccak256(
            abi.encode(
                PERMIT_TYPEHASH,
                _amount,
                msg.sender,
                nonces[msg.sender]++,
                _deadline
            )
        );

        bytes32 hash = keccak256(
            abi.encodePacked("\x19\x01", getDomainSeparator(), signatureData)
        );

        Safe(payable(safeAddress)).checkSignatures(
            hash,
            abi.encodePacked(signatureData),
            _signatures
        );

        bytes memory data = abi.encodeWithSignature(
            "transfer(address,uint256)",
            _beneficiary,
            _amount
        );

        require(
            Safe(payable(safeAddress)).execTransactionFromModule(
                tokenAddress,
                0,
                data,
                Enum.Operation.Call
            ),
            "Could not execute token transfer"
        );
    }

    function getDomainSeparator() private view returns (bytes32) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }

        return keccak256(
            abi.encode(
                keccak256(
                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
                ),
                keccak256(bytes("TokenWithdrawModule")),
                keccak256(bytes("1")),
                chainId,
                address(this)
            )
        );
    }
}
```

### Setup demo user interface

Initialize a new repository from the [Safe demo template](https://github.com/5afe/safe-demo-template). Clone the repository to your local machine.

#### Step 1: Install dependencies

```bash
pnpm i
```

#### Step 2: Setup project

Copy the `.example.env` file to `.env` and update the values if necessary. For now, you can keep the default values.

```bash
cp .example.env .env
```

#### Step 3: Start the development server

```bash
pnpm dev
```

#### Step 4: Add a scaffold React component

Now, replace the content of `app/page.tsx` with the following code. It includes all necessary imports, the React component and the UI, and empty functions you will fill with code in the following steps. From now on, you will only work on this file.

```tsx
// TODO
```

You can now run the development server with `pnpm dev` and open the app in your browser at `http://localhost:3000`. You should see a card that asks you to connect two wallets. Connect two wallets to proceed with the tutorial. 

#### Step 5: Initialize the clients

In the first step, you create the clients that allow you to interact with the smart account. As permissionless.js is just a tiny wrapper around viem, you will use many of viem's functions in this tutorial. 

To add this code, overwrite the `init` function with this one:

```tsx
const init = async () => {
  // The safe account is created using the public client:
  const safeAccount = ; // TODO

  const isSafeDeployed = await safeAccount.isDeployed()

  setSafeAddress(safeAccount.address)
  setSafeIsDeployed(isSafeDeployed)

  // Check whether the module has been installed already:
  const isModuleInstalled =
    isSafeDeployed &&
    (await smartAccountClient.isModuleInstalled({
      address: ownableExecutorModule,
      type: 'executor',
      context: '0x'
    }))

  setModuleIsInstalled(isModuleInstalled)

  // We store the clients in the state to use them in the following steps:
  setSafeAccount(safeAccount)
  setSmartAccountClient(smartAccountClient)

  console.log('setup done')
}
```

You must refresh your page after adding this code, as the initial site load will trigger the `init` function and set up the Safe account and the Smart account client. You can check the console to see if the setup was successful.

#### Step 6: Sign token approval as Safe owner

```tsx
// TODO
```

#### Step 7: Send a transaction via the TokenTransferModule

```tsx
// TODO
```

#### Step 8: Disable the TokenTransferModule

The last step is to uninstall the module. If the module is no longer needed, you can remove it from the smart account.

Replace the `uninstallModule` function with this code:

```tsx
const uninstallModule = async () => {
  setLoading(true)
  console.log('Disabling module...')

  // To uninstall the module, use the `uninstallModule`.
  // You have to pack the abi parameter yourself:
  // - previousEntry (address): The address of the previous entry in the module sentinel list.
  // - deInitData (bytes): The data that is passed to the deInit function of the module.
  // As this is the only module, the previous entry is the sentinel address 0x1. The deInitData is empty for the
  // OwnableExecutor.
  const userOp = await smartAccountClient?.uninstallModule({
    type: 'executor',
    address: ownableExecutorModule,
    context: encodeAbiParameters(
      parseAbiParameters('address prevEntry, bytes memory deInitData'),
      ['0x0000000000000000000000000000000000000001', '0x']
    )
  })

  console.log('User operation:', userOp, '\nwaiting for tx receipt...')

  // We wait for the transaction to be settled:
  const receipt = await pimlicoClient.waitForUserOperationReceipt({
    hash: userOp as `0x${string}`
  })

  console.log('Module uninstalled, tx receipt:', receipt)
  setModuleIsUninstalled(true)
  setLoading(false)
}
```

In the last step of the UI, you can now click the “Uninstall Module” button to remove the module from the smart account.

That’s it! You have successfully built an app that can interact with a Safe Smart Account using the ERC-7579 standard. You can now deploy and test your app with your Safes and modules.

## Do more with Safe and Safe Modules

Did you encounter any difficulties? Let us know by opening [an issue](https://github.com/5afe/safe-module-tutorial/issues/new) or asking a question on [Stack Exchange](https://ethereum.stackexchange.com/questions/tagged/safe-core) with the `safe-core` tag.
