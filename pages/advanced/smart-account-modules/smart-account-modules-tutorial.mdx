import { Callout } from 'nextra/components'

# How to build an app with Safe and Safe Modules

In this tutorial, you will:

- Build a Safe Module
- Enable an example module on a Safe (the [TokenWithdrawModule](https://github.com/5afe/safe-module-tutorial-contracts) module)
- Send a transaction via the TokenWithdrawModule (Send a transaction that transfers ERC20 token from the Safe account)

## Prerequisites

**Prerequisite knowledge:** You will need some basic experience with [Solidity](https://docs.soliditylang.org/en/latest/) and [Hardhat](https://hardhat.org).

Before progressing with the tutorial, please make sure you have the following:

- Downloaded and installed [Node.js](https://nodejs.org/en/download/package-manager) and [npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).

## Setup contracts repository

This tutorial will guide creating a Safe Module that allows users to withdraw ERC20 tokens from a Safe account, provided that the Safe owners have given their approval in the form of off-chain signatures. The primary use case is to enable beneficiaries to withdraw tokens themselves without requiring the Safe owners to execute transactions directly.

### Limitations
- Each beneficiary has an independent sequential nonce, requiring them to withdraw tokens one at a time in the correct order based on their own nonce.
- The withdrawal using module will work only for specific token and Safe address set during the module deployment.

### Initialize a new project

```bash
npm init
```
You can choose all default values.

### Install dependencies

Add overrides in `package.json` so that there are no peer dependency related issues.

```json
...
  "overrides": {
    "@safe-global/safe-contracts": {
      "ethers": "^6.13.5"
    }
  }
...
```

```bash
npm add hardhat @safe-global/safe-contracts @openzeppelin/contracts
```

### Initialize hardhat project

Select create TypeScript project.

```bash
npx hardhat init
```

```bash
npx hardhat compile
```

### Update hardhat.config.ts

When compiling Safe contracts with solidity 0.8.x the bytecode size exceeds the limit of 24KB. To overcome this, set `allowUnlimitedContractSize` to `true` in the hardhat config.
In practise with production networks, use the officially deployed Safe contracts.
Also, add `dependencyCompiler` to import `SafeProxyFactory` contract.

```typescript
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import "hardhat-dependency-compiler";

const config: HardhatUserConfig = {
  solidity: "0.8.28",
  networks: {
    hardhat: {
      allowUnlimitedContractSize: true,
    },
  },
  dependencyCompiler: {
    paths: [
      "@safe-global/safe-contracts/contracts/proxies/SafeProxyFactory.sol",
    ],
  },
};

export default config;

```

### Create a new Solidity contract

Delete the default `contracts/Lock.sol` and test file `test/Lock.ts` and create a new Solidity contract `TokenWithdrawModule.sol` in the `contracts` directory.

`TokenWithdrawModule.sol` will contain the module code which will be used further in the tutorial for interacting with the UI.

#### Step 1. Create empty contract

```solidity
// SPDX-License-Identifier: LGPL-3.0
pragma solidity ^0.8.0;
// Imports will be added here

contract TokenWithdrawModule {
  // State variables will be added here

  // Constructor will be added here

  // Functions will be added here
}
```

Explanation:
- **SPDX License Identifier**: Specifies the license type.
- **`pragma solidity ^0.8.0`**: Defines the Solidity compiler version.
- **`contract TokenWithdrawModule`**: Declares the contract name.

#### Step 2: Import required dependencies

```solidity
import "@safe-global/safe-contracts/contracts/common/Enum.sol";
import "@safe-global/safe-contracts/contracts/Safe.sol";
```

Explanation:
- **`Enum.sol`**: Provides Enum `Operation` which can have values like `Call` or `DelegateCall`. This will be used further in the contract when a module calls a Safe account where the module specifies the operation type.
- **`Safe.sol`**: Includes the Safe contract interface to interact with Safe accounts.

#### Step 3: Define state variables

Declare the necessary state variables for the contract.

```solidity
bytes32 public immutable PERMIT_TYPEHASH =
    keccak256(
      "TokenWithdrawModule(uint256 amount,address _beneficiary,uint256 nonce,uint256 deadline)"
    );
address public immutable safeAddress;
address public immutable tokenAddress;
mapping(address => uint256) public nonces;
```

Explanation:
- **`PERMIT_TYPEHASH`**: Used to construct the signature hash for the token transfer. 
- **`safeAddress`**: Stores the Safe contract address.
- **`tokenAddress`**: Stores the ERC20 token contract address.
- **`nonces`**: Tracks unique nonce to prevent replay attacks.

#### Step 4: Create the Constructor

Define a constructor to initialize the Safe and token contract addresses.

```solidity
constructor(address _tokenAddress, address _safeAddress) {
    tokenAddress = _tokenAddress;
    safeAddress = _safeAddress;
}
```

- Initializes `tokenAddress` and `safeAddress` with provided values during deployment. Thus, in this module the token and Safe addresses are fixed.

#### Step 5: Implement the `getDomainSeparator` function

Add a helper function to compute the EIP-712 domain separator.

```solidity
  function getDomainSeparator() private view returns (bytes32) {

      return keccak256(
          abi.encode(
              keccak256(
                  "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
              ),
              keccak256(bytes("TokenWithdrawModule")),
              keccak256(bytes("1")),
              block.chainid,
              address(this)
          )
      );
  }
```

Explanation:
- Computes the `EIP712Domain` separator for the current chain and contract.
- Ensures compatibility with the EIP-712 standard for off-chain signing.
- Using a Domain separator ensures that the signature is valid for specific contracts in context and the chain. Thus, preventing replay attacks.

#### Step 6: Implement the `tokenTransfer` function

Add a function to handle token transfers from the Safe.

```solidity
function tokenTransfer(
    uint _amount,
    address _beneficiary,
    uint256 _deadline,
    bytes memory _signatures
) public {
    require(_deadline >= block.timestamp, "expired deadline");

    bytes32 signatureData = keccak256(
        abi.encode(
            PERMIT_TYPEHASH,
            _amount,
            msg.sender,
            nonces[msg.sender]++,
            _deadline
        )
    );

    bytes32 hash = keccak256(
        abi.encodePacked("\x19\x01", getDomainSeparator(), signatureData)
    );

    Safe(payable(safeAddress)).checkSignatures(
        hash,
        abi.encodePacked(signatureData),
        _signatures
    );

    bytes memory data = abi.encodeWithSignature(
        "transfer(address,uint256)",
        _beneficiary,
        _amount
    );

    require(
        Safe(payable(safeAddress)).execTransactionFromModule(
            tokenAddress,
            0,
            data,
            Enum.Operation.Call
        ),
        "Could not execute token transfer"
    );
}
```

Explanation:
1. **Parameter Validation**:
   - Ensure the `_deadline` is valid.
   - Construct `signatureData` with the provided details and `PERMIT_TYPEHASH`.
2. **Hash Calculation**:
   - Compute the hash using the `EIP712` format to ensure signature consistency.
3. **Signature Verification**:
   - Call `checkSignatures` on the Safe to verify the signatures provided match the owners of the Safe.
4. **Transaction Execution**:
   - A module can use `execwhenTransactionFromModule` or `execTransactionFromModuleReturnData` function to execute transactions through a Safe account on which the module is enabled.
   - Encode the transfer call using `abi.encodeWithSignature`.
   - Use `execTransactionFromModule` to execute the token transfer via the Safe.
   - Ensure execution succeeds, otherwise revert.

#### Final contract code

Here is the complete code for reference:

```solidity
// SPDX-License-Identifier: LGPL-3.0
pragma solidity ^0.8.0;
import "@safe-global/safe-contracts/contracts/common/Enum.sol";
import "@safe-global/safe-contracts/contracts/Safe.sol";

/**
 * @title TokenWithdrawModule
 * @dev Contract implementing the a module that transfers tokens from a Safe contract to the user having a valid signature.
 */
contract TokenWithdrawModule {
    bytes32 public immutable PERMIT_TYPEHASH =
        keccak256(
            "TokenWithdrawModule(uint256 amount,address _beneficiary,uint256 nonce,uint256 deadline)"
        );
    address public immutable safeAddress;
    address public immutable tokenAddress;
    mapping(address => uint256) public nonces;

    /**
     * @dev Constructor function for the contract
     *
     * @param _tokenAddress address of the ERC20 token contract
     * @param _safeAddress address of the Safe contract
     */
    constructor(address _tokenAddress, address _safeAddress) {
        tokenAddress = _tokenAddress;
        safeAddress = _safeAddress;
    }

    /**
     * @dev Transfers a specified amount of tokens to a beneficiary.
     *
     * @param _amount amount of tokens to be transferred
     * @param _beneficiary address of the beneficiary
     * @param _deadline deadline for the validity of the signature
     * @param _signatures signatures of the Safe owner(s)
     */
    function tokenTransfer(
        uint _amount,
        address _beneficiary,
        uint256 _deadline,
        bytes memory _signatures
    ) public {
        require(_deadline >= block.timestamp, "expired deadline");

        bytes32 signatureData = keccak256(
            abi.encode(
                PERMIT_TYPEHASH,
                _amount,
                msg.sender,
                nonces[msg.sender]++,
                _deadline
            )
        );
        
        bytes32 hash = keccak256(
            abi.encodePacked("\x19\x01", getDomainSeparator(), signatureData)
        );

        Safe(payable(safeAddress)).checkSignatures(
            hash,
            abi.encodePacked(signatureData),
            _signatures
        );

        bytes memory data = abi.encodeWithSignature(
            "transfer(address,uint256)",
            _beneficiary,
            _amount
        );

        require(
            Safe(payable(safeAddress)).execTransactionFromModule(
                tokenAddress,
                0,
                data,
                Enum.Operation.Call
            ),
            "Could not execute token transfer"
        );
    }

  function getDomainSeparator() private view returns (bytes32) {

      return keccak256(
          abi.encode(
              keccak256(
                  "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
              ),
              keccak256(bytes("TokenWithdrawModule")),
              keccak256(bytes("1")),
              block.chainid,
              address(this)
          )
      );
  }
}
```

#### Create TestToken.sol contract

Create a new file in the `contracts` directory named `TestToken.sol` and add the following code:

```solidity
// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract TestToken is ERC20, Ownable {
    constructor(
        string memory _name,
        string memory _symbol
    ) ERC20(_name, _symbol) Ownable(msg.sender){}

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
```

### Testing the contract

#### Step 1: Create test/utils/utils.ts file

Create a new file named `utils.ts` in the `test/utils` directory and include the code below.

```typescript
import { ethers } from "hardhat";
import { Signer, AddressLike, BigNumberish, ZeroAddress } from "ethers";
import { Safe } from "../../typechain-types";

/**
 * Executes a transaction on the Safe contract.
 * @param wallets - The signers of the transaction.
 * @param safe - The Safe contract instance.
 * @param to - The address to send the transaction to.
 * @param value - The value to send with the transaction.
 * @param data - The data to send with the transaction.
 * @param operation - The operation type (0 for call, 1 for delegate call).
 */
const execTransaction = async function (
  wallets: Signer[],
  safe: Safe,
  to: AddressLike,
  value: BigNumberish,
  data: string,
  operation: number,
): Promise<void> {
  // Get the current nonce of the Safe contract
  const nonce = await safe.nonce();

  // Get the transaction hash for the Safe transaction
  const transactionHash = await safe.getTransactionHash(
    to,
    value,
    data,
    operation,
    0,
    0,
    0,
    ZeroAddress,
    ZeroAddress,
    nonce
  );

  let signatureBytes = "0x";
  const bytesDataHash = ethers.getBytes(transactionHash);

  // Get the addresses of the signers
  const addresses = await Promise.all(wallets.map(wallet => wallet.getAddress()));
  // Sort the signers by their addresses
  const sorted = wallets.sort((a, b) => {
    const addressA = addresses[wallets.indexOf(a)];
    const addressB = addresses[wallets.indexOf(b)];
    return addressA.localeCompare(addressB, "en", { sensitivity: "base" });
  });

  // Sign the transaction hash with each signer
  for (let i = 0; i < sorted.length; i++) {
    const flatSig = (await sorted[i].signMessage(bytesDataHash))
      .replace(/1b$/, "1f")
      .replace(/1c$/, "20");
    signatureBytes += flatSig.slice(2);
  }

  // Execute the transaction on the Safe contract
  await safe.execTransaction(
    to,
    value,
    data,
    operation,
    0,
    0,
    0,
    ZeroAddress,
    ZeroAddress,
    signatureBytes
  );
};

export {
  execTransaction,
};
```

Explanation:
- This file contains utility function to execute transaction through the Safe account.

#### Step 2: Start with an empty test file

Create a new file named `TokenWithdrawModule.test.ts` and include the following basic structure:

```typescript
// Import necessary libraries and types

describe("TokenWithdrawModule Tests", function () {

  // Define variables
   
  // Before hook to setup the contracts
  before(async () => {
  });

  // Add your test cases here
 it("Should successfully transfer tokens to bob", async function () {

 });
```

#### Step 3: Setup contracts and variables

```typescript
// Import necessary libraries and types
import { ethers } from "hardhat";
import { expect } from "chai";
import { Signer, ZeroAddress } from "ethers";
import { Safe__factory, TestToken, TokenWithdrawModule } from "../typechain-types";
import { execTransaction } from "./utils/utils";

describe("TokenWithdrawModule Tests", function () {

  // Define variables
  let deployer: Signer;
  let alice: Signer;
  let bob: Signer;
  let charlie: Signer;
  let masterCopy: any;
  let proxyFactory: any;
  let token: TestToken;
  let safeFactory: Safe__factory;
  let chainId: bigint;

    // Setup signers and deploy contracts before running tests
  before(async () => {
    [deployer, alice, bob, charlie] = await ethers.getSigners();

    chainId = (await ethers.provider.getNetwork()).chainId;
    safeFactory = await ethers.getContractFactory("Safe", deployer);
    masterCopy = await safeFactory.deploy();

    // Deploy a new token contract before each test
    token = await (
      await ethers.getContractFactory("TestToken", deployer)
    ).deploy("test", "T");

    proxyFactory = await (
      await ethers.getContractFactory("SafeProxyFactory", deployer)
    ).deploy();
  });

  // Setup contracts: Deploy a new token contract, create a new Safe, deploy the TokenWithdrawModule contract, and nable the module in the Safe.
  const setupContracts = async (
    walletOwners: Signer[],
    threshold: number
  ): Promise<{ exampleModule: TokenWithdrawModule }> => {
    const ownerAddresses = await Promise.all(
      walletOwners.map(async (walletOwner) => await walletOwner.getAddress())
    );

    const safeData = masterCopy.interface.encodeFunctionData("setup", [
      ownerAddresses,
      threshold,
      ZeroAddress,
      "0x",
      ZeroAddress,
      ZeroAddress,
      0,
      ZeroAddress,
    ]);

    // Read the safe address by executing the static call to createProxyWithNonce function
    const safeAddress = await proxyFactory.createProxyWithNonce.staticCall(
      await masterCopy.getAddress(),
      safeData,
      0n
    );

    // Create the proxy with nonce
    await proxyFactory.createProxyWithNonce(
      await masterCopy.getAddress(),
      safeData,
      0n
    );

    if (safeAddress === ZeroAddress) {
      throw new Error("Safe address not found");
    }

    // Deploy the TokenWithdrawModule contract
    const exampleModule = await (
      await ethers.getContractFactory("TokenWithdrawModule", deployer)
    ).deploy(token.target, safeAddress);

    // Mint tokens to the safe address
    await token
      .connect(deployer)
      .mint(safeAddress, BigInt(10) ** BigInt(18) * BigInt(100000));

    const safe = await ethers.getContractAt("Safe", safeAddress);

    // Enable the module in the safe
    const enableModuleData = masterCopy.interface.encodeFunctionData(
      "enableModule",
      [exampleModule.target]
    );

    // Execute the transaction to enable the module
    await execTransaction(
      walletOwners.slice(0, threshold),
      safe,
      safe.target,
      0,
      enableModuleData,
      0
    );

    // Verify that the module is enabled
    expect(await safe.isModuleEnabled.staticCall(exampleModule.target)).to.be
      .true;

    return { exampleModule };
  };
});

```

Explanation:
This step will set up the necessary contracts and variables for the tests. This includes deploying the Safe contract, the Token contract, and the TokenWithdrawModule contract. It will also initialize the Safe with the required owners and enable the TokenWithdrawModule as a module in the Safe.

1. **Import necessary libraries and types**:
   - Import the required libraries and types from `hardhat`, `chai`, and `ethers`.

2. **Define variables**:
   - Define variables to hold the signers, contract instances, and other necessary data.

3. **Setup signers and deploy contracts before running tests**:
   - Use the `before` hook to set up the signers and deploy the `Safe` and `SafeProxyFactory` contracts before running the tests.

4. **Helper function to setup contracts**:
   - Define a helper function `setupContracts` to deploy and initialize the contracts. This function:
     - Deploys the Safe contract and sets up the owners and threshold.
     - Deploys the TokenWithdrawModule contract.
     - Mints tokens to the Safe address.
     - Enables the TokenWithdrawModule in the Safe.
     - Verifies that the module is enabled in the Safe.

#### Step 4: Add test case

```typescript
  // Test case to verify token transfer to bob
  it("Should successfully transfer tokens to bob", async function () {
    const wallets = [alice];
    const { exampleModule } = await setupContracts(wallets, 1);

    const amount = BigInt(10) ** BigInt(18) * BigInt(10);
    const deadline = 100000000000000n;
    const nonce = await exampleModule.nonces(await bob.getAddress());

    // Define the EIP-712 domain and types
    const domain: TypedDataDomain = {
      name: "TokenWithdrawModule",
      version: "1",
      chainId: chainId,
      verifyingContract: await exampleModule.getAddress(),
    };

    const types = {
      TokenWithdrawModule: [
        { name: "amount", type: "uint256" },
        { name: "_beneficiary", type: "address" },
        { name: "nonce", type: "uint256" },
        { name: "deadline", type: "uint256" },
      ],
    };

    const value = {
      amount: amount,
      _beneficiary: await bob.getAddress(),
      nonce: nonce,
      deadline: deadline,
    };

    const digest = ethers.TypedDataEncoder.hash(domain, types, value);
    const bytesDataHash = ethers.getBytes(digest);
    let signatureBytes = "0x";
    // Sign the digest with each wallet owner
    for (let i = 0; i < wallets.length; i++) {
      const flatSig = (await wallets[i].signMessage(bytesDataHash))
        .replace(/1b$/, "1f")
        .replace(/1c$/, "20");
      signatureBytes += flatSig.slice(2);
    }

    // Attempt to transfer tokens with an invalid signer (should fail)
    await expect(
      exampleModule
        .connect(charlie)
        .tokenTransfer(amount, await charlie.getAddress(), deadline, signatureBytes)
    ).to.be.revertedWith("GS026");

    // Transfer tokens with a valid signer
    await exampleModule
      .connect(bob)
      .tokenTransfer(amount, await bob.getAddress(), deadline, signatureBytes);

    // Verify the token balance of bob
    const balanceBob = await token.balanceOf.staticCall(await bob.getAddress());
    expect(balanceBob).to.be.equal(amount);
  });
```

This step adds a test case to verify that the `TokenWithdrawModule` correctly transfers tokens from the Safe to a beneficiary.

1. **Define the test case**:
   - Define a test case named "Should successfully transfer tokens to bob".

2. **Setup contracts**:
   - Call the `setupContracts` helper function to deploy and initialize the contracts with the required owners and threshold.

3. **Define transfer parameters**:
   - Define the amount of tokens to transfer and the deadline for the transaction.

4. **Generate the digest**:
   - Generate the EIP-712 digest for the token transfer.

5. **Sign the digest**:
   - Sign the digest with the wallet owners' private keys to produce the required signatures.

6. **Try invalid transfer**:
   - Try to transfer tokens with an invalid signer (charlie) and expect the transaction to revert.

7. **Execute valid transfer**:
   - Execute the token transfer with a valid signer (bob) and verify that the transfer is successful.

8. **Verify token balance**:
   - Check the token balance of bob to ensure that the tokens were transferred correctly.

This test case ensures that the `TokenWithdrawModule` correctly handles token transfers, including signature verification and transaction execution.


#### Final test code

Here is the complete code for reference:

```typescript
import { ethers } from "hardhat";
import { expect } from "chai";
import { Signer, TypedDataDomain, ZeroAddress } from "ethers";
import { Safe, Safe__factory, SafeProxyFactory, TestToken, TokenWithdrawModule } from "../typechain-types";
import { execTransaction } from "./utils/utils";

describe("Example module tests", async function () {
  let deployer: Signer;
  let alice: Signer;
  let bob: Signer;
  let charlie: Signer;
  let masterCopy: Safe;
  let proxyFactory: SafeProxyFactory;
  let token: TestToken;
  let safeFactory: Safe__factory;
  let chainId: bigint;

  // Setup signers and deploy contracts before running tests
  before(async () => {
    [deployer, alice, bob, charlie] = await ethers.getSigners();

    chainId = (await ethers.provider.getNetwork()).chainId;
    safeFactory = await ethers.getContractFactory("Safe", deployer);
    masterCopy = await safeFactory.deploy();

    // Deploy a new token contract before each test
    token = await (
      await ethers.getContractFactory("TestToken", deployer)
    ).deploy("test", "T");

    proxyFactory = await (
      await ethers.getContractFactory("SafeProxyFactory", deployer)
    ).deploy();
  });

  // Setup contracts: Deploy a new token contract, create a new Safe, deploy the TokenWithdrawModule contract, and enable the module in the Safe.
  const setupContracts = async (
    walletOwners: Signer[],
    threshold: number
  ): Promise<{ exampleModule: TokenWithdrawModule }> => {
    const ownerAddresses = await Promise.all(
      walletOwners.map(async (walletOwner) => await walletOwner.getAddress())
    );

    const safeData = masterCopy.interface.encodeFunctionData("setup", [
      ownerAddresses,
      threshold,
      ZeroAddress,
      "0x",
      ZeroAddress,
      ZeroAddress,
      0,
      ZeroAddress,
    ]);

    // Read the safe address by executing the static call to createProxyWithNonce function
    const safeAddress = await proxyFactory.createProxyWithNonce.staticCall(
      await masterCopy.getAddress(),
      safeData,
      0n
    );

    // Create the proxy with nonce
    await proxyFactory.createProxyWithNonce(
      await masterCopy.getAddress(),
      safeData,
      0n
    );

    if (safeAddress === ZeroAddress) {
      throw new Error("Safe address not found");
    }

    // Deploy the TokenWithdrawModule contract
    const exampleModule = await (
      await ethers.getContractFactory("TokenWithdrawModule", deployer)
    ).deploy(token.target, safeAddress);

    // Mint tokens to the safe address
    await token
      .connect(deployer)
      .mint(safeAddress, BigInt(10) ** BigInt(18) * BigInt(100000));

    const safe = await ethers.getContractAt("Safe", safeAddress);

    // Enable the module in the safe
    const enableModuleData = masterCopy.interface.encodeFunctionData(
      "enableModule",
      [exampleModule.target]
    );

    // Execute the transaction to enable the module
    await execTransaction(
      walletOwners.slice(0, threshold),
      safe,
      safe.target,
      0,
      enableModuleData,
      0
    );

    // Verify that the module is enabled
    expect(await safe.isModuleEnabled.staticCall(exampleModule.target)).to.be
      .true;

    return { exampleModule };
  };

  // Test case to verify token transfer to bob
  it("Should successfully transfer tokens to bob", async function () {
    const wallets = [alice];
    const { exampleModule } = await setupContracts(wallets, 1);

    const amount = BigInt(10) ** BigInt(18) * BigInt(10);
    const deadline = 100000000000000n;
    const nonce = await exampleModule.nonces(await bob.getAddress());

    // Define the EIP-712 domain and types
    const domain: TypedDataDomain = {
      name: "TokenWithdrawModule",
      version: "1",
      chainId: chainId,
      verifyingContract: await exampleModule.getAddress(),
    };

    const types = {
      TokenWithdrawModule: [
        { name: "amount", type: "uint256" },
        { name: "_beneficiary", type: "address" },
        { name: "nonce", type: "uint256" },
        { name: "deadline", type: "uint256" },
      ],
    };

    const value = {
      amount: amount,
      _beneficiary: await bob.getAddress(),
      nonce: nonce,
      deadline: deadline,
    };

    const digest = ethers.TypedDataEncoder.hash(domain, types, value);
    const bytesDataHash = ethers.getBytes(digest);
    let signatureBytes = "0x";
    // Sign the digest with each wallet owner
    for (let i = 0; i < wallets.length; i++) {
      const flatSig = (await wallets[i].signMessage(bytesDataHash))
        .replace(/1b$/, "1f")
        .replace(/1c$/, "20");
      signatureBytes += flatSig.slice(2);
    }

    // Attempt to transfer tokens with an invalid signer (should fail)
    await expect(
      exampleModule
        .connect(charlie)
        .tokenTransfer(amount, await charlie.getAddress(), deadline, signatureBytes)
    ).to.be.revertedWith("GS026");

    // Transfer tokens with a valid signer
    await exampleModule
      .connect(bob)
      .tokenTransfer(amount, await bob.getAddress(), deadline, signatureBytes);

    // Verify the token balance of bob
    const balanceBob = await token.balanceOf.staticCall(await bob.getAddress());
    expect(balanceBob).to.be.equal(amount);
  });
});
```

### Run the tests

```bash
npx hardhat test
```

## Do more with Safe and Safe Modules

Did you encounter any difficulties? Let us know by opening [an issue](https://github.com/5afe/safe-module-tutorial/issues/new) or asking a question on [Stack Exchange](https://ethereum.stackexchange.com/questions/tagged/safe-core) with the `safe-core` tag.
