import { Callout } from 'nextra/components'

# How to build an app with Safe and Safe Module

In this tutorial, you will build an app that can:

- Build a Safe Module
- Enable an example module on a Safe (the [TokenTransferModule](https://github.com/5afe/safe-module-tutorial-contracts) module)
- Send a transaction via the TokenTransferModule (Send a transaction that transfers ERC20 token from the Safe account)

The full code for this tutorial is in the [Safe Module tutorial repository](https://github.com/5afe/safe-module-tutorial).

## Prerequisites

**Prerequisite knowledge:** You will need some basic experience with [React](https://react.dev/learn), [Next.js](https://nextjs.org/docs), [Solidity](https://docs.soliditylang.org/en/latest/) and [Hardhat](https://hardhat.org).

Before progressing with the tutorial, please make sure you have the following:

- Downloaded and installed [Node.js](https://nodejs.org/en/download/package-manager) and [pnpm](https://pnpm.io/installation).
- Metamask installed in your browser and connected to the Sepolia network.
- Two test accounts in Metamask, the second with some Sepolia Eth for gas.

## Setup contracts repository

This tutorial will provide a guide to create a Safe Module that allows users to withdraw ERC20 tokens from a Safe account, provided that the Safe owners have given their approval in the form of off-chain signatures. The primary use case is to enable beneficiaries to withdraw tokens themselves without requiring the Safe owners to execute transactions directly.

### Use cases
- Simplifies token withdrawal by enabling beneficiaries to perform withdrawals themselves.
- Reduces the need for Safe owners to execute each transaction on-chain.

### Limitations
- Beneficiaries must be externally owned accounts (EOAs) and cannot be smart contracts.
- The nonce is sequential for simplicity
- The contract will work only for specific token and Safe address provided during deployment.

### Initialize a new repository

```bash
git init
```

```bash
npm init
```

### Install dependencies

Add overrides in `package.json` so that we don't face any peer dependency related issues.

```json
...
  "overrides": {
    "ethers": "^6.13.5"
  }
...
```

```bash
npm add hardhat @safe-global/safe-contracts @openzeppelin/contracts
```

### Update hardhat.config.ts

When compiling Safe contracts with solidity 0.8.x the bytecode size exceeds the limit of 24KB. To overcome this, set `allowUnlimitedContractSize` to `true` in the hardhat config.
Also, add `dependencyCompiler` to import `SafeProxyFactory` contract.

```typescript
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import "hardhat-dependency-compiler";

const config: HardhatUserConfig = {
  solidity: "0.8.28",
  networks: {
    hardhat: {
      allowUnlimitedContractSize: true,
    },
  },
  dependencyCompiler: {
    paths: [
      "@safe-global/safe-contracts/contracts/proxies/SafeProxyFactory.sol",
    ],
  },
};

export default config;

```

### Initialize hardhat project

Select create TypeScript project.

```bash
npx hardhat init
```

```bash
npx hardhat compile
```

### Create a new Solidity contract

Delete the default `Lock.sol` and test file `Lock.ts` and create a new Solidity contract `TokenTransferModule.sol` in the `contracts` directory.

`TokenTransferModule.sol` will contain the module code which will be used further in the tutorial for interacting with the UI.

#### Step 1. Create empty contract

```solidity
// SPDX-License-Identifier: LGPL-3.0
pragma solidity ^0.8.0;

contract TokenTransferModule {
}
```

Explanation:
- **SPDX License Identifier**: Specifies the license type.
- **`pragma solidity ^0.8.0`**: Defines the Solidity compiler version.
- **`contract TokenWithdrawModule`**: Declares the contract name.

#### Step 2: Import required dependencies


```solidity
import "@safe-global/safe-contracts/contracts/common/Enum.sol";
import "@safe-global/safe-contracts/contracts/Safe.sol";
```

Explanation:
- **`Enum.sol`**: Provides Enum `Operation` which can have values like `Call` or `DelegateCall`. This will be used further in the contract when a module calls a Safe account where the module specifies the operation type.
- **`Safe.sol`**: Includes the Safe contract interface to interact with Safe accounts.

#### Step 3: Define state variables

Declare the necessary state variables for the contract.

```solidity
bytes32 public immutable PERMIT_TYPEHASH =
    keccak256(
        "TokenTransfer(uint256 amount, address _beneficiary, uint256 nonce, uint256 deadline)"
    );
address public immutable safeAddress;
address public immutable tokenAddress;
mapping(address => uint256) public nonces;
```

Explanation:
- **`PERMIT_TYPEHASH`**: Used to construct the signature hash for the token transfer. 
- **`safeAddress`**: Stores the Safe contract address.
- **`tokenAddress`**: Stores the ERC20 token contract address.
- **`nonces`**: Tracks unique nonce to prevent replay attacks.

#### Step 4: Create the Constructor

Define a constructor to initialize the Safe and token contract addresses.

```solidity
constructor(address _tokenAddress, address _safeAddress) {
    tokenAddress = _tokenAddress;
    safeAddress = _safeAddress;
}
```

- Initializes `tokenAddress` and `safeAddress` with provided values during deployment. Thus, in this module the token and Safe addresses are fixed.

#### Step 5: Implement the `tokenTransfer` function

Add a function to handle token transfers from the Safe.

```solidity
function tokenTransfer(
    uint _amount,
    address _beneficiary,
    uint256 _deadline,
    bytes memory _signatures
) public {
    require(_deadline >= block.timestamp, "expired deadline");

    bytes32 signatureData = keccak256(
        abi.encode(
            PERMIT_TYPEHASH,
            _amount,
            msg.sender,
            nonces[msg.sender]++,
            _deadline
        )
    );

    bytes32 hash = keccak256(
        abi.encodePacked("\x19\x01", getDomainSeparator(), signatureData)
    );

    Safe(payable(safeAddress)).checkSignatures(
        hash,
        abi.encodePacked(signatureData),
        _signatures
    );

    bytes memory data = abi.encodeWithSignature(
        "transfer(address,uint256)",
        _beneficiary,
        _amount
    );

    require(
        Safe(payable(safeAddress)).execTransactionFromModule(
            tokenAddress,
            0,
            data,
            Enum.Operation.Call
        ),
        "Could not execute token transfer"
    );
}
```

Explanation:
1. **Parameter Validation**:
   - Ensure the `_deadline` is valid.
   - Construct `signatureData` with the provided details and `PERMIT_TYPEHASH`.
2. **Hash Calculation**:
   - Compute the hash using the `EIP712` format to ensure signature consistency.
3. **Signature Verification**:
   - Call `checkSignatures` on the Safe to verify the signatures provided match the owners of the Safe.
4. **Transaction Execution**:
   - A module can use `execwhenTransactionFromModule` or `execTransactionFromModuleReturnData` function to execute transactions through a Safe account on which the module is enabled.
   - Encode the transfer call using `abi.encodeWithSignature`.
   - Use `execTransactionFromModule` to execute the token transfer via the Safe.
   - Ensure execution succeeds, otherwise revert.

#### Step 6: Implement the `getDomainSeparator` function

Add a helper function to compute the EIP-712 domain separator.

```solidity
function getDomainSeparator() private view returns (bytes32) {
    uint256 chainId;
    assembly {
        chainId := chainid()
    }

    return keccak256(
        abi.encode(
            keccak256(
                "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
            ),
            keccak256(bytes("TokenWithdrawModule")),
            keccak256(bytes("1")),
            chainId,
            address(this)
        )
    );
}
```

Explanation:
- Computes the `EIP712Domain` separator for the current chain and contract.
- Ensures compatibility with the EIP-712 standard for off-chain signing.
- Using a Domain separator ensures that the signature is valid for specific contracts in context and the chain. Thus, preventing replay attacks.

#### Final contract code

Here is the complete code for reference:

```solidity
// SPDX-License-Identifier: LGPL-3.0
pragma solidity ^0.8.0;
import "@safe-global/safe-contracts/contracts/common/Enum.sol";
import "@safe-global/safe-contracts/contracts/Safe.sol";

contract TokenWithdrawModule {
    bytes32 public immutable PERMIT_TYPEHASH =
        keccak256(
            "TokenTransfer(uint256 amount, address _beneficiary, uint256 nonce, uint256 deadline)"
        );
    address public immutable safeAddress;
    address public immutable tokenAddress;
    mapping(address => uint256) public nonces;

    constructor(address _tokenAddress, address _safeAddress) {
        tokenAddress = _tokenAddress;
        safeAddress = _safeAddress;
    }

    function tokenTransfer(
        uint _amount,
        address _beneficiary,
        uint256 _deadline,
        bytes memory _signatures
    ) public {
        require(_deadline >= block.timestamp, "expired deadline");

        bytes32 signatureData = keccak256(
            abi.encode(
                PERMIT_TYPEHASH,
                _amount,
                msg.sender,
                nonces[msg.sender]++,
                _deadline
            )
        );

        bytes32 hash = keccak256(
            abi.encodePacked("\x19\x01", getDomainSeparator(), signatureData)
        );

        Safe(payable(safeAddress)).checkSignatures(
            hash,
            abi.encodePacked(signatureData),
            _signatures
        );

        bytes memory data = abi.encodeWithSignature(
            "transfer(address,uint256)",
            _beneficiary,
            _amount
        );

        require(
            Safe(payable(safeAddress)).execTransactionFromModule(
                tokenAddress,
                0,
                data,
                Enum.Operation.Call
            ),
            "Could not execute token transfer"
        );
    }

    function getDomainSeparator() private view returns (bytes32) {
        uint256 chainId;
        assembly {
            chainId := chainid()
        }

        return keccak256(
            abi.encode(
                keccak256(
                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
                ),
                keccak256(bytes("TokenWithdrawModule")),
                keccak256(bytes("1")),
                chainId,
                address(this)
            )
        );
    }
}
```

### Testing the contract




## Do more with Safe and Safe Modules

Did you encounter any difficulties? Let us know by opening [an issue](https://github.com/5afe/safe-module-tutorial/issues/new) or asking a question on [Stack Exchange](https://ethereum.stackexchange.com/questions/tagged/safe-core) with the `safe-core` tag.
