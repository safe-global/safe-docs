import { Tabs, Steps } from 'nextra/components'
import { Grid } from '@mui/material'
import CustomCard from '../../../components/CustomCard'

# Sponsor UserOperations with Pimlico

In this guide you will learn how to sponsor the deployment of an ERC-4337 Safe account and its future user operations using [Pimlico](https://pimlico.io) infrastructure and the [permissionless](https://npmjs.com/permissionless) library.

`permissionless` is a TypeScript library focused on building with the ERC-4337 stack, including smart accounts, bundlers, paymasters, and user operations. Some of its core principles are providing a great developer experience and avoiding vendor lock-in by supporting different providers and ERC-4337 smart accounts, including Safe.

## Prerequisites

- [Node.js and npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).
- A [Pimlico account](https://dashboard.pimlico.io) and an API key.

## Steps

<Steps>

### Install dependencies

Install [viem](https://npmjs.com/viem) and [permissionless](https://npmjs.com/permissionless) dependencies by running the following command:

```bash
pnpm install viem permissionless
```

### Contracts

This guide is built on Gnosis Chain, so all the contracts used are deployed on that network. Check the commented links in the code snippet to get the right addresses in case you use a different network.

As you can see in the URLs, we will use some specific versions for the following contracts:
- `v0.6.0` EntryPoint
- `v1.4.1` Safe Smart Account
- `v0.2.0` Safe4337Module
- `v0.2.0` AddModuleLib

```typescript
const ENTRYPOINT_ADDRESS_V06 = '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789'

// https://github.com/safe-global/safe-modules-deployments/blob/main/src/assets/safe-4337-module/v0.2.0/add-modules-lib.json#L8
const ADD_MODULE_LIB_ADDRESS = '0x8EcD4ec46D4D2a6B64fE960B3D64e8B94B2234eb'

// https://github.com/safe-global/safe-modules-deployments/blob/main/src/assets/safe-4337-module/v0.2.0/safe-4337-module.json#L8
const SAFE_4337_MODULE_ADDRESS = '0xa581c4A4DB7175302464fF3C06380BC3270b4037'

// https://github.com/safe-global/safe-deployments/blob/main/src/assets/v1.4.1/safe_proxy_factory.json#L13
const SAFE_PROXY_FACTORY_ADDRESS = '0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67'

// https://github.com/safe-global/safe-deployments/blob/main/src/assets/v1.4.1/safe.json#L13
const SAFE_SINGLETON_ADDRESS = '0x41675C099F32341bf84BFc5382aF534df5C7461a'

// https://github.com/safe-global/safe-deployments/blob/main/src/assets/v1.4.1/multi_send.json#L13
const SAFE_MULTISEND_ADDRESS = '0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526'
```

### Imports

These are all the imports required in the script we are building for this guide, that include `permissionless` and `viem` packages. There is also a `utils.ts` file where some utility functions are implemented and will be shared in the sections below.

```typescript
import { bundlerActions, getAccountNonce } from 'permissionless'
import { pimlicoBundlerActions, pimlicoPaymasterActions } from 'permissionless/actions/pimlico'
import { Address, Client, Hash, Hex, PrivateKeyAccount, createClient, createPublicClient, encodeFunctionData, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { gnosis } from 'viem/chains'
import { getAccountAddress, getAccountInitCode } from './utils'
```

### Create a signer

First of all, we need a signer instance that will be the owner of the Safe account once it is deployed.

```typescript
const PRIVATE_KEY = '0x...'

const signer = privateKeyToAccount(PRIVATE_KEY as Hash)
```

### Initialize the clients

To query the blockchain network and operate with Pimlico infrastructure we need to create a few client instances.

Firstly, we instantiate a standard `publicClient` instance for regular Ethereum RPC calls. To do this we have first to define the corresponding RPC URL depending on the network we are using.

```typescript
const rpcURL = 'https://rpc.ankr.com/gnosis'

const publicClient = createPublicClient({
  transport: http(rpcURL),
  chain: gnosis
})
```

Secondly, we instantiate the `bundlerClient` using the Pimlico API `v1`, that is dedicated for Bundler methods. This API requires a `PIMLICO_API_KEY` that we can get from their [dashboard](https://dashboard.pimlico.io/apikeys).

```typescript
const PIMLICO_API_V1 = `https://api.pimlico.io/v1/gnosis/rpc?apikey=${PIMLICO_API_KEY}`

const bundlerClient = createClient({
  transport: http(PIMLICO_API_V1),
  chain: gnosis
})
  .extend(bundlerActions)
  .extend(pimlicoBundlerActions)
```

Lastly, we instantiate the `pimlicoPaymasterClient` using the Pimlico API `v2`, that is dedicated for Paymaster methods and responsible for interacting with Pimlico's Verifying Paymaster endpoint and requesting sponsorship.

```typescript
const PIMLICO_API_V2 = `https://api.pimlico.io/v2/gnosis/rpc?apikey=${PIMLICO_API_KEY}`

const pimlicoPaymasterClient = createClient({
  transport: http(PIMLICO_API_V2),
  chain: gnosis
}).extend(pimlicoPaymasterActions)
```

### Create an ERC-4337 Safe

A counterfactual account is a smart account that is not deployed yet but the address where it will be deployed is already known. This is allowed thanks to deterministic deployments and it depends on the address of the factory contract and the 

We can create a counterfactual Safe

```typescript
const saltNonce = BigInt(process.env.PIMLICO_NONCE as string)
```

Check this list of [ERC-20 Pimlico paymasters and USDC tokens addresses](https://docs.pimlico.io/paymaster/erc20-paymaster/contract-addresses) to select the right addresses for these contracts depending on the network. In this guide we will be using the following ones.

```typescript
const ERC20_PAYMASTER_ADDRESS = '0x000000000034B78bfe02Be30AE4D324c8702803d'

const USDC_TOKEN_ADDRESS = '0xddafbb505ad214d7b80b1f830fccc89b60fb7a83'
```

<Tabs items={['script.ts', 'utils.ts']}>
  <Tabs.Tab>
    ```typescript
    import { getAccountInitCode } from './utils'

    const initCode = await getAccountInitCode({
      owner: signer.address,
      addModuleLibAddress: ADD_MODULE_LIB_ADDRESS,
      safe4337ModuleAddress: SAFE_4337_MODULE_ADDRESS,
      safeProxyFactoryAddress: SAFE_PROXY_FACTORY_ADDRESS,
      safeSingletonAddress: SAFE_SINGLETON_ADDRESS,
      saltNonce,
      multiSendAddress: MULTISEND_ADDRESS,
      erc20TokenAddress: USDC_TOKEN_ADDRESS,
      paymasterAddress: ERC20_PAYMASTER_ADDRESS
    })
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```typescript
    const getAccountInitCode = async ({
      owner,
      addModuleLibAddress,
      safe4337ModuleAddress,
      safeProxyFactoryAddress,
      safeSingletonAddress,
      saltNonce = 0n,
      multiSendAddress,
      erc20TokenAddress,
      paymasterAddress,
    }: {
      owner: Address
      addModuleLibAddress: Address
      safe4337ModuleAddress: Address
      safeProxyFactoryAddress: Address
      safeSingletonAddress: Address
      saltNonce?: bigint
      multiSendAddress: Address
      erc20TokenAddress: Address
      paymasterAddress: Address
    }): Promise<Hex> => {
      if (!owner) throw new Error('Owner account not found')
      const initializer = await getInitializerCode({
        owner,
        addModuleLibAddress,
        safe4337ModuleAddress,
        multiSendAddress,
        erc20TokenAddress,
        paymasterAddress,
      })

      const initCodeCallData = encodeFunctionData({
        abi: [
          {
            inputs: [
              {
                internalType: 'address',
                name: '_singleton',
                type: 'address',
              },
              {
                internalType: 'bytes',
                name: 'initializer',
                type: 'bytes',
              },
              {
                internalType: 'uint256',
                name: 'saltNonce',
                type: 'uint256',
              },
            ],
            name: 'createProxyWithNonce',
            outputs: [
              {
                internalType: 'contract SafeProxy',
                name: 'proxy',
                type: 'address',
              },
            ],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ],
        functionName: 'createProxyWithNonce',
        args: [safeSingletonAddress, initializer, saltNonce],
      })

      return concatHex([safeProxyFactoryAddress, initCodeCallData])
    }
    ```
  </Tabs.Tab>
</Tabs>

<Tabs items={['script.ts', 'utils.ts']}>
  <Tabs.Tab>
    ```typescript
    import { getAccountAddress } from './utils'

    const senderAddress = await getAccountAddress({
      client: publicClient,
      owner: signer.address,
      addModuleLibAddress: ADD_MODULE_LIB_ADDRESS,
      safe4337ModuleAddress: SAFE_4337_MODULE_ADDRESS,
      safeProxyFactoryAddress: SAFE_PROXY_FACTORY_ADDRESS,
      safeSingletonAddress: SAFE_SINGLETON_ADDRESS,
      saltNonce,
      multiSendAddress: MULTISEND_ADDRESS,
      erc20TokenAddress: USDC_TOKEN_ADDRESS,
      paymasterAddress: ERC20_PAYMASTER_ADDRESS
    })
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```typescript
    const getAccountAddress = async ({
      client,
      owner,
      addModuleLibAddress,
      safe4337ModuleAddress,
      safeProxyFactoryAddress,
      safeSingletonAddress,
      saltNonce = 0n,
      multiSendAddress,
      erc20TokenAddress,
      paymasterAddress,
    }: {
      client: PublicClient
      owner: Address
      addModuleLibAddress: Address
      safe4337ModuleAddress: Address
      safeProxyFactoryAddress: Address
      safeSingletonAddress: Address
      saltNonce?: bigint
      multiSendAddress: Address
      erc20TokenAddress: Address
      paymasterAddress: Address
    }): Promise<Address> => {
      const proxyCreationCode = await client.readContract({
        abi: [
          {
            inputs: [],
            name: 'proxyCreationCode',
            outputs: [
              {
                internalType: 'bytes',
                name: '',
                type: 'bytes',
              },
            ],
            stateMutability: 'pure',
            type: 'function',
          },
        ],
        address: safeProxyFactoryAddress,
        functionName: 'proxyCreationCode',
      })

      const deploymentCode = encodePacked(
        ['bytes', 'uint256'],
        [proxyCreationCode, hexToBigInt(safeSingletonAddress)]
      )

      const initializer = await getInitializerCode({
        owner,
        addModuleLibAddress,
        safe4337ModuleAddress,
        multiSendAddress,
        erc20TokenAddress,
        paymasterAddress,
      })

      const salt = keccak256(encodePacked(['bytes32', 'uint256'], [keccak256(encodePacked(['bytes'], [initializer])), saltNonce]))

      return getContractAddress({
        from: safeProxyFactoryAddress,
        salt,
        bytecode: deploymentCode,
        opcode: 'CREATE2',
      })
    }

    const getInitializerCode = async ({
      owner,
      addModuleLibAddress,
      safe4337ModuleAddress,
      multiSendAddress,
      erc20TokenAddress,
      paymasterAddress,
    }: {
      owner: Address
      addModuleLibAddress: Address
      safe4337ModuleAddress: Address
      multiSendAddress: Address
      erc20TokenAddress: Address
      paymasterAddress: Address
    }) => {
      const setupTxs: InternalTx[] = [
        {
          to: addModuleLibAddress,
          data: enableModuleCallData(safe4337ModuleAddress),
          value: 0n,
          operation: 1, // 1 = DelegateCall required for enabling the module
        },
      ]

      if (erc20TokenAddress != zeroAddress && paymasterAddress != zeroAddress) {
        setupTxs.push({
          to: erc20TokenAddress,
          data: generateApproveCallData(paymasterAddress),
          value: 0n,
          operation: 0, // 0 = Call
        })
      }

      const multiSendCallData = encodeMultiSend(setupTxs)

      return encodeFunctionData({
        abi: [
          {
            inputs: [
              {
                internalType: 'address[]',
                name: '_owners',
                type: 'address[]',
              },
              {
                internalType: 'uint256',
                name: '_threshold',
                type: 'uint256',
              },
              {
                internalType: 'address',
                name: 'to',
                type: 'address',
              },
              {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
              },
              {
                internalType: 'address',
                name: 'fallbackHandler',
                type: 'address',
              },
              {
                internalType: 'address',
                name: 'paymentToken',
                type: 'address',
              },
              {
                internalType: 'uint256',
                name: 'payment',
                type: 'uint256',
              },
              {
                internalType: 'address payable',
                name: 'paymentReceiver',
                type: 'address',
              },
            ],
            name: 'setup',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ],
        functionName: 'setup',
        args: [[owner], 1n, multiSendAddress, multiSendCallData, safe4337ModuleAddress, zeroAddress, 0n, zeroAddress],
      })
    }

    const enableModuleCallData = (safe4337ModuleAddress: `0x${string}`) => {
      return encodeFunctionData({
        abi: [
          {
            inputs: [
              {
                internalType: 'address[]',
                name: 'modules',
                type: 'address[]',
              },
            ],
            name: 'enableModules',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ],
        functionName: 'enableModules',
        args: [[safe4337ModuleAddress]],
      })
    }

    const encodeMultiSend = (txs: InternalTx[]): `0x${string}` => {
      const data: `0x${string}` = `0x${txs.map((tx) => encodeInternalTransaction(tx)).join('')}`

      return encodeFunctionData({
        abi: [
          {
            inputs: [{ internalType: 'bytes', name: 'transactions', type: 'bytes' }],
            name: 'multiSend',
            outputs: [],
            stateMutability: 'payable',
            type: 'function',
          },
        ],
        functionName: 'multiSend',
        args: [data],
      })
    }

    const encodeInternalTransaction = (tx: InternalTx): string => {
      const encoded = encodePacked(
        ['uint8', 'address', 'uint256', 'uint256', 'bytes'],
        [tx.operation, tx.to, tx.value, BigInt(tx.data.slice(2).length / 2), tx.data],
      )
      return encoded.slice(2)
    }
    ```
  </Tabs.Tab>
</Tabs>

After calculating the predicted address of the counterfactual ERC-4773 Safe account, the `senderAddress`, we can check on the [Gnosis Chain block explorer](https://gnosisscan.io) that the account is not deployed yet.

### Create a UserOperation

<Tabs items={['script.ts', 'utils.ts']}>
  <Tabs.Tab>
    ```typescript
    import { encodeCallData } from './utils'

    const newNonce = await getAccountNonce(publicClient as Client, {
      entryPoint: ,
      sender: senderAddress,
    })

    const txCallData: `0x${string}` = encodeCallData({
      to: senderAddress,
      data: '0x',
      value: 0n,
    })
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```typescript
    const encodeCallData = (params: { to: Address; value: bigint; data: `0x${string}` }) => {
      return encodeFunctionData({
        abi: [
          {
            inputs: [
              {
                internalType: 'address',
                name: 'to',
                type: 'address',
              },
              {
                internalType: 'uint256',
                name: 'value',
                type: 'uint256',
              },
              {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
              },
              {
                internalType: 'uint8',
                name: 'operation',
                type: 'uint8',
              },
            ],
            name: 'executeUserOp',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function',
          },
        ],
        functionName: 'executeUserOp',
        args: [params.to, params.value, params.data, 0],
      })
    }
    ```
  </Tabs.Tab>
</Tabs>

```typescript
type UserOperation = {
  sender: Address
  nonce: bigint
  initCode: Hex
  callData: Hex
  callGasLimit: bigint
  verificationGasLimit: bigint
  preVerificationGas: bigint
  maxFeePerGas: bigint
  maxPriorityFeePerGas: bigint
  paymasterAndData: Hex
  signature: Hex
}

const contractCode = await publicClient.getBytecode({ address: senderAddress })

const sponsoredUserOperation: UserOperation = {
  sender: senderAddress,
  nonce: newNonce,
  initCode: contractCode ? '0x' : initCode,
  callData: txCallData,
  callGasLimit: 1n, // All Gas Values will be filled by Estimation Response Data.
  verificationGasLimit: 1n,
  preVerificationGas: 1n,
  maxFeePerGas: 1n,
  maxPriorityFeePerGas: 1n,
  paymasterAndData: ERC20_PAYMASTER_ADDRESS,
  signature: '0x'
}
```

### Estimate the UserOperation gas

To estimate the gas limits for a `UserOperation` we call the `estimateUserOperationGas` method from the bundler, which receives the `userOperation` and `entryPoint` as parameters.

After that we call the `getUserOperationGasPrice` method to get the maximum gas price and add all the returned values to the `sponsoredUserOperation`.

```typescript
const gasEstimate = await bundlerClient.estimateUserOperationGas({
  userOperation: sponsoredUserOperation,
  entryPoint: ENTRYPOINT_ADDRESS_V06
})
const maxGasPriceResult = await bundlerClient.getUserOperationGasPrice()

sponsoredUserOperation.callGasLimit = gasEstimate.callGasLimit
sponsoredUserOperation.verificationGasLimit = gasEstimate.verificationGasLimit
sponsoredUserOperation.preVerificationGas = gasEstimate.preVerificationGas
sponsoredUserOperation.maxFeePerGas = maxGasPriceResult.fast.maxFeePerGas
sponsoredUserOperation.maxPriorityFeePerGas = maxGasPriceResult.fast.maxPriorityFeePerGas
```

If we want to use the Paymaster to pay for the fees, we need to provide a `POLICY_ID` that can be provided by a third party willing to sponsor our `UserOperation`(s) or can be generated in the [Pimlico dashboard](https://dashboard.pimlico.io/sponsorship-policies). Sponsorship policies allow to define custom rules for sponsorships with a variety of options to limit the amount of sponsorships in total, per user, and per user operation.

On top of that, we need to overwrite some gas values from the Paymaster and add the `paymasterAndData` to the `sponsoredUserOperation`.

```typescript
if (usePaymaster) {
  const sponsorResult = await pimlicoPaymasterClient.sponsorUserOperation({
    userOperation: sponsoredUserOperation,
    entryPoint: ENTRYPOINT_ADDRESS_V06,
    sponsorshipPolicyId: POLICY_ID
  })

  sponsoredUserOperation.callGasLimit = sponsorResult.callGasLimit
  sponsoredUserOperation.verificationGasLimit = sponsorResult.verificationGasLimit
  sponsoredUserOperation.preVerificationGas = sponsorResult.preVerificationGas
  sponsoredUserOperation.paymasterAndData = sponsorResult.paymasterAndData
}
```

In case we don't want to use a Paymaster to pay for the gas fees we need to make sure the Safe account holds at least 1 USD token, as the fees will be extracted from the Safe itself.

### Sign the UserOperation

To sign the `sponsoredUserOperation` we have created a utility function that returns the signature from the signer and accepts the following parameters. Check the `utils.ts` tab to see its implementation.

<Tabs items={['script.ts', 'utils.ts']}>
  <Tabs.Tab>
    ```typescript
    import { signUserOperation } from './utils'

    sponsoredUserOperation.signature = await signUserOperation(
      sponsoredUserOperation,
      signer,
      chainId: 100
      SAFE_4337_MODULE_ADDRESS
    )
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```typescript
    const EIP712_SAFE_OPERATION_TYPE = {
      SafeOp: [
        { type: 'address', name: 'safe' },
        { type: 'uint256', name: 'nonce' },
        { type: 'bytes', name: 'initCode' },
        { type: 'bytes', name: 'callData' },
        { type: 'uint256', name: 'callGasLimit' },
        { type: 'uint256', name: 'verificationGasLimit' },
        { type: 'uint256', name: 'preVerificationGas' },
        { type: 'uint256', name: 'maxFeePerGas' },
        { type: 'uint256', name: 'maxPriorityFeePerGas' },
        { type: 'bytes', name: 'paymasterAndData' },
        { type: 'uint48', name: 'validAfter' },
        { type: 'uint48', name: 'validUntil' },
        { type: 'address', name: 'entryPoint' },
      ],
    }

    const signUserOperation = async (
      userOperation: UserOperation,
      signer: PrivateKeyAccount,
      chainId: any,
      safe4337ModuleAddress: any
    ) => {
      const signatures = [
        {
          signer: signer.address,
          data: await signer.signTypedData({
            domain: {
              chainId,
              verifyingContract: safe4337ModuleAddress,
            },
            types: EIP712_SAFE_OPERATION_TYPE,
            primaryType: 'SafeOp',
            message: {
              safe: userOperation.sender,
              nonce: userOperation.nonce,
              initCode: userOperation.initCode,
              callData: userOperation.callData,
              callGasLimit: userOperation.callGasLimit,
              verificationGasLimit: userOperation.verificationGasLimit,
              preVerificationGas: userOperation.preVerificationGas,
              maxFeePerGas: userOperation.maxFeePerGas,
              maxPriorityFeePerGas: userOperation.maxPriorityFeePerGas,
              paymasterAndData: userOperation.paymasterAndData,
              validAfter: '0x000000000000',
              validUntil: '0x000000000000',
              entryPoint: ENTRYPOINT_ADDRESS_V06,
            },
          }),
        },
      ]
      signatures.sort((left, right) => left.signer.toLowerCase().localeCompare(right.signer.toLowerCase()))
      let signatureBytes: Address = '0x000000000000000000000000'
      for (const sig of signatures) {
        signatureBytes += sig.data.slice(2)
      }
      return signatureBytes
    }
    ```
  </Tabs.Tab>
</Tabs>

### Submit the UserOperation

Call the `sendUserOperation` method from the bundler to submit the `sponsoredUserOperation` to the `EntryPoint` contract.

```typescript
const userOperationHash = await bundlerClient.sendUserOperation({
  userOperation: sponsoredUserOperation,
  entryPoint: ENTRYPOINT_ADDRESS_V06,
})
```

To get more details about the submitted `UserOperation` copy the value of the `userOperationHash` returned, visit the [UserOp Explorer](https://jiffyscan.xyz/?network=gnosis) and paste it in the search bar.

Lastly, to get more details about the transaction we can get the receipt of the `sponsoredUserOperation`, get the `transactionHash`, and check the tansaction details in the [Gnosis Chain block explorer](https://gnosisscan.io).

```typescript
const receipt = await bundlerClient.waitForUserOperationReceipt({
  hash: userOperationHash
})

const transactionHash = receipt.receipt.transactionHash
```

</Steps>

## Recap and further reading

This guide covered how to sponsor the deployment of a new ERC-4337 Safe and its user operations with Pimlico infrastructure using of a Paymaster.

Feel free to try out other ideas and posibilities, as there are many more regarding:
- The deployment and initial setup of ERC-4337 accounts.
- Who is responsible for paying for the transaction fees.
- The tokens used to pay the transaction fees.

This includes, but is not limited to:

- Turning an existing Safe account into an ERC-4337 Safe account.
- Paying the transaction fees from a Safe account in the native token.
- Paying the transaction fees from a Safe account in an ERC-20 token.

Explore our [4337-gas-metering](https://github.com/safe-global/safe-modules/tree/main/examples/4337-gas-metering) repository on GitHub to see how most of these options work with Safe and notice the integrations with different providers like Alchemy, Gelato, and Pimlico (where you will find most of the code used in this guide).
