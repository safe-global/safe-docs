import { Tabs, Callout } from 'nextra/components'

import LegacyCallout from '../../../../components/callouts/LegacyCallout.mdx'
import OnlySafeTxCallout from '../../../../components/callouts/OnlySafeTxCallout.mdx'
import ReentrancyCallout from '../../../../components/callouts/ReentrancyCallout.mdx'
import IrreversibilityCallout from '../../../../components/callouts/IrreversibilityCallout.mdx'



# `multiSend` (0x8d80ff0a)



This method is payable as delegatecalls keep the msg.value from the previous call
If the calling method (e.g. execTransaction) received ETH this would revert otherwise
Sends multiple transactions and reverts all if one fails.




Defined in [` MultiSend.sol`](https://github.com/safe-global/safe-smart-account/tree/v1.4.1/contracts/libraries/MultiSend.sol#L30)


## Usage

{/* <!-- vale off --> */}

<Tabs items={['example.sol']}>
  <Tabs.Tab>
    ```solidity
    interface ISafe {
        function multiSend(bytes memory transactions) public payable
    }

    contract Example {
        function example() ... {
            (ISafe safe).multiSend(
                "0x..."
            );
        }
    }
    ```
  </Tabs.Tab>
</Tabs>

{/* <!-- vale on --> */}



## Parameters

### `transactions`

  - **Type:** `bytes`

  Encoded transactions. Each transaction is encoded as a packed bytes of operation as a uint8 with 0 for a call or 1 for a delegatecall (=> 1 byte), to as a address (=> 20 bytes), value as a uint256 (=> 32 bytes), data length as a uint256 (=> 32 bytes), data as bytes. see abi.encodePacked for more information on packed encoding

  ```solidity focus=2
  (ISafe safe).multiSend(
    "0x..."
  );
  ```





